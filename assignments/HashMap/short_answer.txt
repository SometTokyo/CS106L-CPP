Assignment 3: STL HashMap (short answer questions)
Names:
1.at() vs []
  Explain the difference between at() and the implementation of the operator []. Wy did you have to overload one and not the other?
  Hint: You will likely only need to read the header comments to do this

  Answer: at() can throw an exception, while [] inserts the element and initializes it if not found.
  Overloading [] provides an easy way to access the array. These two methods provide different functions and usage scenarios.
  Answer:at()å¯ä»¥æŠ›å‡ºå¼‚å¸¸ï¼Œ[]åˆ™æ˜¯å‘ç°æ²¡æœ‰è¯¥å…ƒç´ æ—¶æ’å…¥è¯¥å…ƒç´ å¹¶åˆå§‹åŒ–ã€‚é‡è½½[]æ˜¯æä¾›ä¸€ç§ç®€æ˜“çš„æ•°ç»„è®¿é—®æ–¹å¼ï¼Œè¿™ä¸¤ç§æ–¹æ³•æä¾›çš„åŠŸèƒ½å’Œä½¿ç”¨åœºæ™¯æ˜¯ä¸åŒçš„ã€‚

2.Find vs. ğ“•ğ“²ğ“·ğ“­
  In addition to the HashMap::find member function, there is also a std::find function in the STL algorithms library. If you were searching for key k in HashMap m, is it preferable to call m.find(k) or std::find(m.begin(), m.end(), k)?
  Hint: on average, there are a constant number of elements per bucket. Also, one of these functions has a faster Big-O complexity because one of them uses a loop while another does something smarter.

  Answer: It's better to call m.find(k), which has lower complexity.
  Answer:è°ƒç”¨m.find(k)æ›´å¥½ï¼Œå¤æ‚åº¦æ›´ä½ã€‚

3.RAII?
  This HashMap class is RAII-compliant. Explain why.

  Answer: The destructor ensures that all resources are released after the scope ends.
  Answer:ææ„å‡½æ•°ä¿è¯äº†åœ¨ä½œç”¨åŸŸç»“æŸåé‡Šæ”¾æ‰€æœ‰èµ„æºã€‚

4.Increments
  Briefly explain the implementation of HashMapIterator's operator++, which we provide for you. How does it work and what checks does it have?

  Answer: The prefix increment first increments the node. If it is empty, it goes to the next bucket. If it is still empty, it returns itself;
  otherwise, it returns the incremented node. The postfix increment first makes a copy to return itself and then uses the prefix operation to increment.
  Answer:å‰ç¼€é€’å¢é¦–å…ˆé€’å¢èŠ‚ç‚¹ï¼Œå¦‚æœä¸ºç©ºï¼Œåˆ™å‰å¾€ä¸‹ä¸€ä¸ªæ¡¶ï¼Œå¦‚æœè¿˜æ˜¯ä¸ºç©ºåˆ™è¿”å›è‡ªèº«ï¼Œå¦åˆ™åˆ™è¿”å›é€’å¢åçš„èŠ‚ç‚¹ï¼›åç¼€é€’å¢åˆ™å…ˆåˆ¶ä½œä¸€ä¸ªå‰¯æœ¬æ¥è¿”å›è‡ªèº«ï¼Œç„¶åå†ä½¿ç”¨å‰ç¼€è¿ç®—æ¥é€’å¢ã€‚

5.Attachment Issues
  Why is it that we need to implement the special member functions in the HashMap class, but we can default all the special member functions in the HashMapIterator class?
  Hint: your answer should reference the Rule of Five (the Rule of 3 including move operations) vs. the Rule of Zero, and also talk about std::vector's copy constructor/assignment operator.

  Answer: HashMap manages its dynamic memory and resources, such as nodes, so it follows the rule of five and needs to implement all SMFs in full.
  The iterator only stores pointers and values and doesn't manage dynamic resources, so there's no need for a custom implementation.
  Answer:HashMapè‡ªå·±ç®¡ç†åŠ¨æ€å†…å­˜å’Œèµ„æºï¼Œä¾‹å¦‚èŠ‚ç‚¹ï¼Œæ‰€ä»¥éµå¾ªrule of fiveï¼Œéœ€è¦å…¨éƒ¨å®ç°SMFï¼Œè¿­ä»£å™¨åˆ™åªæ˜¯å­˜å‚¨æŒ‡é’ˆå’Œæ•°å€¼ï¼Œè‡ªå·±å¹¶ä¸ç®¡ç†åŠ¨æ€èµ„æºï¼Œå› æ­¤ä¸éœ€è¦è‡ªå®šä¹‰å®ç°ã€‚

6.Move Semantics
  In your move constructor or move assignment operator, why did you have to std::move each member, even though the parameter (named rhs) is already an r-value reference?

  Answer: Even though rhs is a right reference, its members might not be.
  Answer:å°½ç®¡rhsæ˜¯å³æŒ‡å¼•ç”¨ï¼Œä½†æ˜¯ä»–çš„æˆå‘˜ä¸ä¸€å®šæ˜¯ã€‚